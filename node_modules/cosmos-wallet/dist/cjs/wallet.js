"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const amino_1 = require("@cosmjs/amino");
const crypto_1 = require("@cosmjs/crypto");
const encoding_1 = require("@cosmjs/encoding");
const proto_signing_1 = require("@cosmjs/proto-signing");
const helpers_1 = require("./helpers");
class CosmosWallet {
    constructor(direct, privkey, pubkey, address) {
        this.direct = direct;
        this.privkey = privkey;
        this.pubkey = pubkey;
        this.address = address;
    }
    static init(privateKey, prefix = 'cosmos') {
        return __awaiter(this, void 0, void 0, function* () {
            const privkey = encoding_1.fromHex(privateKey);
            const pubkey = yield helpers_1.getPublicKey(privkey);
            const address = helpers_1.getAddressFromPublicKey(pubkey, prefix);
            const direct = yield proto_signing_1.DirectSecp256k1Wallet.fromKey(privkey, prefix);
            return new CosmosWallet(direct, privkey, pubkey, address);
        });
    }
    getAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.direct.getAccounts();
        });
    }
    signDirect(address, signDoc) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.direct.signDirect(address, signDoc);
        });
    }
    signAmino(address, signDoc) {
        return __awaiter(this, void 0, void 0, function* () {
            if (address !== this.address) {
                throw new Error(`Address ${address} not found in wallet`);
            }
            const message = crypto_1.sha256(amino_1.serializeSignDoc(signDoc));
            const sig = yield crypto_1.Secp256k1.createSignature(message, this.privkey);
            const sigBytes = new Uint8Array([...sig.r(32), ...sig.s(32)]);
            const signature = amino_1.encodeSecp256k1Signature(this.pubkey, sigBytes);
            return { signed: signDoc, signature };
        });
    }
}
exports.CosmosWallet = CosmosWallet;
exports.default = CosmosWallet;
//# sourceMappingURL=wallet.js.map