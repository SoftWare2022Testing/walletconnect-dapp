"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const amino_1 = require("@cosmjs/amino");
const crypto_1 = require("@cosmjs/crypto");
const encoding_1 = require("@cosmjs/encoding");
const proto_signing_1 = require("@cosmjs/proto-signing");
const long_1 = __importDefault(require("long"));
const constants_1 = require("../constants");
function getCosmosAddressPrefix(chainId) {
    let prefix = 'cosmos';
    if (typeof chainId !== 'undefined') {
        const [namespace, reference] = chainId.split(':');
        if (namespace !== 'cosmos') {
            throw new Error(`Cannot get address with incompatible namespace for chainId: ${chainId}`);
        }
        const [name] = reference.split('-');
        if (typeof name !== 'undefined') {
            const match = constants_1.COSMOS_ADDRESS_PREFIX[name];
            if (typeof match !== 'undefined') {
                prefix = match;
            }
        }
    }
    return prefix;
}
exports.getCosmosAddressPrefix = getCosmosAddressPrefix;
function getCosmosAddress(publicKey, chainId) {
    const prefix = getCosmosAddressPrefix(chainId);
    return getAddressFromPublicKey(publicKey, prefix);
}
exports.getCosmosAddress = getCosmosAddress;
function getAddressFromPublicKey(publicKey, prefix = 'cosmos') {
    const pubKey = { type: amino_1.pubkeyType.secp256k1, value: encoding_1.toBase64(publicKey) };
    return amino_1.pubkeyToAddress(pubKey, prefix);
}
exports.getAddressFromPublicKey = getAddressFromPublicKey;
function getPublicKey(privkey) {
    return __awaiter(this, void 0, void 0, function* () {
        const uncompressed = (yield crypto_1.Secp256k1.makeKeypair(privkey)).pubkey;
        return crypto_1.Secp256k1.compressPubkey(uncompressed);
    });
}
exports.getPublicKey = getPublicKey;
function stringifySignDocValues(signDoc) {
    return Object.assign(Object.assign({}, signDoc), { bodyBytes: encoding_1.toHex(signDoc.bodyBytes), authInfoBytes: encoding_1.toHex(signDoc.authInfoBytes), accountNumber: signDoc.accountNumber.toString(16) });
}
exports.stringifySignDocValues = stringifySignDocValues;
function parseSignDocValues(signDoc) {
    return Object.assign(Object.assign({}, signDoc), { bodyBytes: encoding_1.fromHex(signDoc.bodyBytes), authInfoBytes: encoding_1.fromHex(signDoc.authInfoBytes), accountNumber: new long_1.default(signDoc.accountNumber) });
}
exports.parseSignDocValues = parseSignDocValues;
function formatDirectSignDoc(fee, pubkey, gasLimit, accountNumber, sequence, bodyBytes, chainId) {
    const authInfoBytes = proto_signing_1.makeAuthInfoBytes([pubkey], fee, gasLimit, sequence);
    const signDoc = proto_signing_1.makeSignDoc(encoding_1.fromHex(bodyBytes), authInfoBytes, chainId, accountNumber);
    return signDoc;
}
exports.formatDirectSignDoc = formatDirectSignDoc;
function stringifyAccountDataValues(account) {
    return Object.assign(Object.assign({}, account), { pubkey: encoding_1.toHex(account.pubkey) });
}
exports.stringifyAccountDataValues = stringifyAccountDataValues;
function parseAccountDataValues(account) {
    return Object.assign(Object.assign({}, account), { pubkey: encoding_1.fromHex(account.pubkey) });
}
exports.parseAccountDataValues = parseAccountDataValues;
function recoverSigningAddress(signature, hash, recoveryIndex) {
    return __awaiter(this, void 0, void 0, function* () {
        if (recoveryIndex > 3) {
            throw new Error('Invalid recovery index');
        }
        const sig = crypto_1.Secp256k1Signature.fromFixedLength(encoding_1.fromBase64(signature));
        const extendedSig = new crypto_1.ExtendedSecp256k1Signature(sig.r(), sig.s(), recoveryIndex);
        try {
            const recoveredPubKey = yield crypto_1.Secp256k1.recoverPubkey(extendedSig, hash);
            return amino_1.pubkeyToAddress({
                type: 'tendermint/PubKeySecp256k1',
                value: encoding_1.toBase64(crypto_1.Secp256k1.compressPubkey(recoveredPubKey)),
            }, 'cosmos');
        }
        catch (_a) {
            return null;
        }
    });
}
exports.recoverSigningAddress = recoverSigningAddress;
function verifySignature(address, signature, hash) {
    return __awaiter(this, void 0, void 0, function* () {
        for (let i = 0; i < 4; i++) {
            const recoveredAddress = yield recoverSigningAddress(signature, hash, i);
            if (recoveredAddress === address) {
                return true;
            }
        }
        return false;
    });
}
exports.verifySignature = verifySignature;
exports.verifyDirectSignature = (address, signature, signDoc) => {
    const messageHash = crypto_1.sha256(proto_signing_1.makeSignBytes(signDoc));
    return verifySignature(address, signature, messageHash);
};
exports.verifyAminoSignature = (address, signature, signDoc) => {
    const messageHash = crypto_1.sha256(amino_1.serializeSignDoc(signDoc));
    return verifySignature(address, signature, messageHash);
};
//# sourceMappingURL=utils.js.map